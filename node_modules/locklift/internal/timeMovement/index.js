"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTimeMovement = exports.TimeMovement = void 0;
const logger_1 = require("../logger");
const seService_1 = require("./seService");
class TimeMovement {
    constructor(seService, clock, isEnabled) {
        this.seService = seService;
        this.clock = clock;
        this.isEnabled = isEnabled;
        /*
         * Returns current offset in seconds
         */
        this.getTimeOffset = () => {
            if (!this.isEnabled) {
                logger_1.logger.printWarn("TimeMovement is disabled");
                return 0;
            }
            return toSeconds(this.clock.offset);
        };
        /*
         * Returns current time
         */
        this.getCurrentTime = () => this.clock.time;
        /*
         * Set node and provider offset in seconds
         @param offsetInSeconds offset in seconds
         */
        this.increaseTime = async (seconds) => {
            if (!this.isEnabled) {
                return logger_1.logger.printWarn("TimeMovement is disabled");
            }
            if (seconds < 0) {
                return logger_1.logger.printWarn("TimeMovement is not allowed to go back in time");
            }
            if (this.seService) {
                this.clock.offset = await this.seService.setTimeOffset(seconds).then(toMs);
            }
            else {
                this.clock.offset += toMs(seconds);
            }
        };
        //TODO make it public when it will be resolved
        this.resetTimeOffset = async () => {
            if (!this.isEnabled) {
                return logger_1.logger.printWarn("TimeMovement is disabled");
            }
            if (this.seService) {
                this.clock.offset = await this.seService.resetTimeOffset().then(toMs);
            }
            else {
                this.clock.offset = 0;
            }
            console.log(`TimeMovement reset to ${this.getTimeOffset()}`);
        };
    }
}
exports.TimeMovement = TimeMovement;
const createTimeMovement = async (clock, connectionConfig) => {
    switch (connectionConfig.connection.type) {
        case "proxy":
            return new TimeMovement(undefined, clock, true);
        case "graphql": {
            const rpcUrl = connectionConfig.connection.data.endpoints[0];
            const rpcOrigin = new URL(rpcUrl).origin;
            const seService = new seService_1.SeService(rpcOrigin);
            const { currentOffsetInSeconds, isEnabled } = await seService
                .getCurrentOffsetTime()
                .then(currentOffsetInSeconds => ({ currentOffsetInSeconds, isEnabled: true }))
                .catch(() => ({ isEnabled: false, currentOffsetInSeconds: 0 }));
            if (currentOffsetInSeconds > 0) {
                logger_1.logger.printWarn(`Current SE time delta is ${currentOffsetInSeconds} seconds. Provider will sync with this offset`);
            }
            clock.offset = toMs(currentOffsetInSeconds);
            return new TimeMovement(seService, clock, isEnabled);
        }
        default:
            return new TimeMovement(undefined, clock, false);
    }
};
exports.createTimeMovement = createTimeMovement;
const toMs = (seconds) => seconds * 1000;
const toSeconds = (ms) => ms / 1000;
