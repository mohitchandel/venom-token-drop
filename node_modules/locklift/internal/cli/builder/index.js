"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Builder = void 0;
const child_process_1 = require("child_process");
const generators_1 = require("../../generators");
const ejs_1 = __importDefault(require("ejs"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importStar(require("path"));
const underscore_1 = __importDefault(require("underscore"));
const utils_1 = require("./utils");
const tablemark = require("tablemark");
const util_1 = require("util");
const rxjs_1 = require("rxjs");
const logger_1 = require("../../logger");
const preload_1 = __importDefault(require("semver/preload"));
const utils_2 = require("../../utils");
const buildCache_1 = require("../../buildCache");
class Builder {
    constructor(config, options, compilerVersion) {
        this.config = config;
        this.compilerVersion = compilerVersion;
        this.nameRegex = /======= (?<contract>.*) =======/g;
        this.docRegex = /(?<doc>^{(\s|.)*?^})/gm;
        this.options = options;
    }
    static create(config, options) {
        const matchedCompilerVersion = (0, child_process_1.execSync)(config.compilerPath + " --version")
            .toString()
            .trim()
            .match(/(?<=Version: )(.*)(?=\+commit)/);
        if (!matchedCompilerVersion) {
            throw new Error("Cannot get compiler version");
        }
        return new Builder(config, options, matchedCompilerVersion[0]);
    }
    async buildContracts() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const contractsTree = (0, utils_2.getContractsTree)(this.options.contracts);
        const { contractArtifacts, contractsToBuild: externalContracts } = await (0, utils_1.resolveExternalContracts)(this.config.externalContracts);
        const totalContracts = [...contractsTree.map(el => el.path), ...externalContracts];
        const buildCache = new buildCache_1.BuildCache(totalContracts, this.options.force, this.options.build);
        const contractsToBuild = await buildCache.buildTree();
        logger_1.logger.printInfo(`Found ${totalContracts.length} sources`);
        if (contractsToBuild.length > 0) {
            logger_1.logger.printInfo(`Found ${contractsToBuild.length} changes, compiling...`);
            try {
                await this.compileContracts(contractsToBuild);
                logger_1.logger.printInfo("Built");
                buildCache.applyCurrentCache();
            }
            catch (err) {
                if (err) {
                    logger_1.logger.printError(err);
                }
                return false;
            }
        }
        else {
            logger_1.logger.printInfo("No changes found, skip compilation");
        }
        if (contractArtifacts.length > 0) {
            contractArtifacts.forEach(artifact => fs_1.default.copyFileSync(artifact, (0, path_1.resolve)(this.options.build, path_1.default.basename(artifact))));
        }
        if (this.config.externalContractsArtifacts) {
            (0, generators_1.copyExternalArtifacts)(this.config.externalContractsArtifacts, this.options.build);
        }
        (0, generators_1.typeGenerator)(this.options.build);
        logger_1.logger.printInfo("factorySource generated");
        return true;
    }
    compileContracts(contractsToBuild) {
        return (0, rxjs_1.lastValueFrom)((0, rxjs_1.from)(contractsToBuild).pipe((0, rxjs_1.map)(el => ({ path: (0, path_1.resolve)(el) })), (0, rxjs_1.map)(el => ({
            ...el,
            contractFileName: (0, utils_1.extractContractName)(el.path),
        })), (0, rxjs_1.mergeMap)(({ path, contractFileName }) => {
            const nodeModules = (0, utils_1.tryToGetNodeModules)();
            return (0, rxjs_1.defer)(async () => {
                if (preload_1.default.lte(this.compilerVersion, "0.66.0")) {
                    const additionalIncludesPath = `--include-path ${(0, path_1.resolve)(process.cwd(), "node_modules")}  ${nodeModules ? `--include-path ${nodeModules}` : ""}`;
                    const includePath = `${additionalIncludesPath}`;
                    const execCommand = `cd ${this.options.build} && \
          ${this.config.compilerPath} ${!this.options.disableIncludePath ? includePath : ""} ${path} ${(this.config.compilerParams || []).join(" ")}`;
                    return (0, util_1.promisify)(child_process_1.exec)(execCommand);
                }
                if (preload_1.default.gte(this.compilerVersion, "0.68.0")) {
                    const additionalIncludesPath = `${nodeModules ? `--include-path ${nodeModules}` : ""}`;
                    const includePath = `${additionalIncludesPath} ${"--base-path"} . `;
                    const execCommand = ` ${this.config.compilerPath} ${!this.options.disableIncludePath ? includePath : ""} -o ${this.options.build}  ${path} ${(this.config.compilerParams || []).join(" ")}`;
                    return (0, util_1.promisify)(child_process_1.exec)(execCommand);
                }
                throw new Error("Unsupported compiler version");
            }).pipe((0, rxjs_1.map)(output => ({
                output,
                contractFileName: (0, path_1.parse)(contractFileName).name,
                path,
            })), (0, rxjs_1.catchError)(e => {
                logger_1.logger.printError(`path: ${path}, contractFile: ${contractFileName} error: ${e?.stderr?.toString() || e}`);
                return (0, rxjs_1.throwError)(undefined);
            }));
        }), 
        //Warnings
        (0, rxjs_1.tap)(output => (0, utils_1.isValidCompilerOutputLog)(output.output.stderr.toString()) &&
            logger_1.logger.printBuilderLog(output.output.stderr.toString())), (0, rxjs_1.filter)(({ output }) => {
            //Only contracts
            return !!output?.stdout.toString();
        }), (0, rxjs_1.mergeMap)(({ contractFileName }) => {
            const lib = this.config.linkerLibPath ? ` --lib ${this.config.linkerLibPath} ` : "";
            const resolvedPathCode = (0, path_1.resolve)(this.options.build, `${contractFileName}.code`);
            const resolvedPathAbi = (0, path_1.resolve)(this.options.build, `${contractFileName}.abi.json`);
            const resolvedPathMap = (0, path_1.resolve)(this.options.build, `${contractFileName}.map.json`);
            return (0, rxjs_1.defer)(async () => {
                const command = `${this.config.linkerPath} compile "${resolvedPathCode}" -a "${resolvedPathAbi}" -o ${(0, path_1.resolve)(this.options.build, `${contractFileName}.tvc`)} ${lib} --debug-map ${resolvedPathMap}`;
                return (0, util_1.promisify)(child_process_1.exec)(command);
            }).pipe((0, rxjs_1.map)(tvmLinkerLog => {
                return tvmLinkerLog.stdout.toString().match(new RegExp("Saved to file (.*)."));
            }), (0, rxjs_1.catchError)(e => {
                logger_1.logger.printError(`contractFileName: ${contractFileName} error:${e?.stderr?.toString()}`);
                return (0, rxjs_1.throwError)(undefined);
            }), (0, rxjs_1.map)(matchResult => {
                if (!matchResult) {
                    throw new Error("Linking error, noting linking");
                }
                return matchResult[1];
            }), (0, rxjs_1.mergeMap)(tvcFile => {
                return (0, rxjs_1.concat)((0, rxjs_1.defer)(() => (0, util_1.promisify)(fs_1.default.writeFile)((0, path_1.resolve)(this.options.build, `${contractFileName}.base64`), (0, utils_1.tvcToBase64)(fs_1.default.readFileSync(tvcFile))))).pipe((0, rxjs_1.catchError)(e => {
                    logger_1.logger.printError(e?.stderr?.toString());
                    return (0, rxjs_1.throwError)(undefined);
                }));
            }));
        }), (0, rxjs_1.toArray)()));
    }
    buildDocs() {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const contractsTree = (0, utils_2.getContractsTree)(this.options.contracts);
        try {
            logger_1.logger.printInfo(`Found ${contractsTree.length} sources`);
            let docs = [];
            contractsTree.map(({ path }) => {
                logger_1.logger.printInfo(`Building ${path}`);
                const output = (0, utils_1.execSyncWrapper)(
                //@ts-ignore
                `cd ${this.options.build} && ${this.config.compilerPath} ./../${path} --${this.options.mode}`);
                logger_1.logger.printInfo(`Compiled ${path}`);
                docs = [...docs, ...this.parseDocs(output.toString())];
            });
            // Filter duplicates by (path, name)
            docs = docs.reduce((acc, doc) => {
                if (acc.find(({ path, name }) => path === doc.path && name === doc.name)) {
                    return acc;
                }
                return [...acc, doc];
            }, []);
            // Sort docs by name (A-Z)
            docs = docs.sort((a, b) => (a.name < b.name ? -1 : 1));
            // Save docs in markdown format
            const render = ejs_1.default.render(fs_1.default.readFileSync((0, path_1.resolve)(__dirname, "./../templates/index.ejs")).toString(), {
                docs,
                tablemark,
            }, {
                rmWhitespace: true,
            });
            //@ts-ignore
            fs_1.default.writeFileSync(
            //@ts-ignore
            (0, path_1.resolve)(process.cwd(), this.options.docs, "index.md"), render);
            logger_1.logger.printInfo("Docs generated successfully!");
        }
        catch (e) {
            logger_1.logger.printError(e);
            return false;
        }
        return true;
    }
    parseDocs(output) {
        const contracts = [...output.matchAll(this.nameRegex)]
            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
            .map(m => m.groups.contract)
            // For the target contracts compiler returns relative path
            // and for dependency contracts paths are absolute
            // Make them all absolute
            .map(c => (0, path_1.resolve)(process.cwd(), this.options.build, c));
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const docs = [...output.matchAll(this.docRegex)].map(m => 
        //@ts-ignore
        JSON.parse(m.groups?.doc));
        return underscore_1.default.zip(contracts, docs).reduce((acc, [contract, doc]) => {
            const [path, name] = contract.split(":");
            // Check name matches the "include" pattern and contract is located in the "contracts" dir
            if (
            //@ts-ignore
            name.match(new RegExp(this.options.include)) !== null &&
                path.startsWith(`${process.cwd()}/${this.options.contracts}`)) {
                return [
                    ...acc,
                    {
                        path: path.replace(`${process.cwd()}/`, ""),
                        name,
                        doc,
                    },
                ];
            }
            return acc;
        }, []);
    }
}
exports.Builder = Builder;
