"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadConfig = exports.JoiConfig = exports.LOCKLIFT_NETWORK_NAME = exports.ConfigState = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const commander_1 = __importDefault(require("commander"));
const nodejs_1 = require("everscale-standalone-client/nodejs");
const joi_1 = __importDefault(require("joi"));
var ConfigState;
(function (ConfigState) {
    ConfigState[ConfigState["EXTERNAL"] = 0] = "EXTERNAL";
    ConfigState[ConfigState["INTERNAL"] = 1] = "INTERNAL";
})(ConfigState = exports.ConfigState || (exports.ConfigState = {}));
exports.LOCKLIFT_NETWORK_NAME = "locklift";
exports.JoiConfig = joi_1.default.object({
    compiler: joi_1.default.alternatives([
        joi_1.default.object({
            includesPath: joi_1.default.string().optional(),
            compilerParams: joi_1.default.array().items(joi_1.default.string()).optional(),
            externalContracts: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.array().items(joi_1.default.string())),
            externalContractsArtifacts: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.array().items(joi_1.default.string())),
            path: joi_1.default.string(),
        }),
        joi_1.default.object({
            includesPath: joi_1.default.string().optional(),
            compilerParams: joi_1.default.array().items(joi_1.default.string()).optional(),
            externalContracts: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.array().items(joi_1.default.string())),
            externalContractsArtifacts: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.array().items(joi_1.default.string())),
            version: joi_1.default.string(),
        }),
    ]),
    linker: joi_1.default.alternatives([
        joi_1.default.object({
            path: joi_1.default.string(),
            lib: joi_1.default.string(),
        }),
        joi_1.default.object({
            version: joi_1.default.string(),
        }),
    ]),
    networks: joi_1.default.object().pattern(joi_1.default.string(), joi_1.default.object({
        giver: joi_1.default.alternatives().conditional(joi_1.default.object({ phrase: joi_1.default.string().required() }).unknown(), {
            then: joi_1.default.object({
                address: joi_1.default.string(),
                giverFactory: joi_1.default.any().optional(),
                phrase: joi_1.default.string(),
                accountId: joi_1.default.number(),
            }),
            otherwise: joi_1.default.object({
                address: joi_1.default.string(),
                giverFactory: joi_1.default.any().optional(),
                key: joi_1.default.string(),
            }),
        }),
        keys: joi_1.default.object({
            path: joi_1.default.string().optional(),
            phrase: joi_1.default.string().optional(),
            amount: joi_1.default.number(),
        }),
        connection: joi_1.default.alternatives([
            ...Object.keys(nodejs_1.NETWORK_PRESETS).map(el => el),
            joi_1.default.object({
                id: joi_1.default.number().optional(),
                type: joi_1.default.alternatives(["graphql", "jrpc", "proxy"]),
                group: joi_1.default.string().optional(),
                data: joi_1.default.alternatives().conditional("type", {
                    is: "graphql",
                    then: joi_1.default.object({
                        endpoints: joi_1.default.array().items(joi_1.default.string()),
                        local: joi_1.default.boolean().optional(),
                        latencyDetectionInterval: joi_1.default.number().optional(),
                        maxLatency: joi_1.default.number().optional(),
                    }),
                    otherwise: joi_1.default.alternatives().conditional("type", {
                        is: "jrpc",
                        then: joi_1.default.object({
                            endpoint: joi_1.default.string(),
                        }),
                        otherwise: joi_1.default.object({
                            connectionFactory: joi_1.default.object().custom((value, helpers) => {
                                return value;
                                // if (value instanceof ConnectionFactory) {
                                //   return value;
                                // }
                                // return helpers.message({"custom": "Invalid proxy connection"});
                            }),
                        }),
                        // otherwise: Joi.object().custom((value, helpers) => {
                        //   if (value instanceof ConnectionFactory) {
                        //     return value;
                        //   }
                        //   return helpers.message({"custom": "Invalid proxy connection"});
                        // }),
                    }),
                }),
            }),
        ]),
        clientConfig: joi_1.default.object({
            message: joi_1.default.object({}).optional().unknown(),
            initInput: joi_1.default.any().optional(),
        }).optional(),
        tracing: joi_1.default.object({
            endpoint: joi_1.default.string(),
        }).optional(),
    }).unknown()),
    mocha: joi_1.default.object({
        tsconfig: joi_1.default.string().optional(),
    }).unknown(true),
}).unknown();
function loadConfig(configPath) {
    const resolvedConfigPath = path_1.default.resolve(process.cwd(), configPath);
    if (!fs_1.default.existsSync(resolvedConfigPath)) {
        throw new commander_1.default.InvalidOptionArgumentError(`Config at ${configPath} not found!`);
    }
    const configFile = require(resolvedConfigPath);
    const validationResult = exports.JoiConfig.validate(configFile.default);
    if (validationResult.error) {
        throw new Error(validationResult.error.annotate());
    }
    const config = { ...validationResult.value };
    for (const [key, value] of Object.entries(config.networks)) {
        if (value.keys != null) {
            value.keys = {
                ...value.keys,
                phrase: value.keys?.phrase || "maze turn choose industry beauty sweet panther valve double report upset mother",
                path: value.keys.path || "m/44'/396'/0'/0/INDEX",
            };
        }
        if (typeof value.connection === "string") {
            value.connection = getPresetParams(value.connection) || value.connection;
        }
        if (key === exports.LOCKLIFT_NETWORK_NAME) {
            config.networks[key] = {
                ...value,
                giver: value.giver || {
                    address: "0:ece57bcc6c530283becbbd8a3b24d3c5987cdddc3c8b7b33be6e4a6312490415",
                    key: "172af540e43a524763dd53b26a066d472a97c4de37d5498170564510608250c3",
                },
            };
        }
    }
    return config;
}
exports.loadConfig = loadConfig;
const getPresetParams = (preset) => {
    if (isKeyofNetworkPreset(preset)) {
        return nodejs_1.NETWORK_PRESETS[preset];
    }
};
const isKeyofNetworkPreset = (preset) => {
    return Object.keys(nodejs_1.NETWORK_PRESETS).find(el => el === preset) !== undefined;
};
