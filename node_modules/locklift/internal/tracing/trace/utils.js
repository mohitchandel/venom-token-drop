"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isErrorExistsInAllowedArr = exports.contractInformation = exports.decoder = void 0;
const types_1 = require("../types");
var TargetType;
(function (TargetType) {
    TargetType["DST"] = "DST";
    TargetType["SRC"] = "SRC";
    TargetType["DEPLOY"] = "DEPLOY";
})(TargetType || (TargetType = {}));
const getCodeAndAddress = (msg, targetType, ctx) => {
    switch (targetType) {
        case TargetType.DST:
            return {
                address: msg.dst,
                codeHash: ctx.accounts[msg.dst]?.codeHash,
            };
        case TargetType.SRC:
            return {
                address: msg.src,
                codeHash: ctx.accounts[msg.src]?.codeHash,
            };
        case TargetType.DEPLOY:
            return {
                codeHash: msg.init?.codeHash,
                address: msg.dst,
            };
    }
};
const decoder = async ({ msgBody, msgType, contract, initialType, }) => {
    const parsedAbi = JSON.parse(contract.contract.abi);
    switch (msgType) {
        case "IntMsg":
        case "ExtIn": {
            const isInternal = msgType === "IntMsg";
            return {
                decoded: await contract.contract
                    .decodeInputMessage({
                    internal: isInternal,
                    body: msgBody,
                    methods: parsedAbi.functions.map(el => el.name),
                })
                    .then(decoded => ({ method: decoded?.method, params: decoded?.input })),
                finalType: initialType,
            };
        }
        case "ExtOut": {
            const outMsg = await contract.contract.decodeOutputMessage({
                body: msgBody,
                methods: parsedAbi.functions.map(el => el.name),
            });
            if (outMsg) {
                return {
                    decoded: outMsg,
                    finalType: types_1.TraceType.FUNCTION_RETURN,
                };
            }
            return {
                decoded: await contract.contract
                    .decodeEvent({
                    body: msgBody,
                    events: parsedAbi.events.map(el => el.name),
                })
                    .then(decoded => ({ params: decoded?.data, method: decoded?.event })),
                finalType: types_1.TraceType.EVENT,
            };
        }
    }
};
exports.decoder = decoder;
const contractInformation = ({ msg, type, ctx, }) => ({
    [types_1.TraceType.DEPLOY]: getCodeAndAddress(msg, TargetType.DEPLOY, ctx),
    [types_1.TraceType.FUNCTION_CALL]: getCodeAndAddress(msg, TargetType.DST, ctx),
    [types_1.TraceType.EVENT]: getCodeAndAddress(msg, TargetType.SRC, ctx),
    [types_1.TraceType.EVENT_OR_FUNCTION_RETURN]: getCodeAndAddress(msg, TargetType.SRC, ctx),
    [types_1.TraceType.BOUNCE]: getCodeAndAddress(msg, TargetType.DST, ctx),
    //TODO
    [types_1.TraceType.FUNCTION_RETURN]: getCodeAndAddress(msg, TargetType.SRC, ctx),
    [types_1.TraceType.TRANSFER]: getCodeAndAddress(msg, TargetType.DST, ctx),
}[type]);
exports.contractInformation = contractInformation;
const isErrorExistsInAllowedArr = (allowedArr, code) => !!allowedArr?.some(el => el === code);
exports.isErrorExistsInAllowedArr = isErrorExistsInAllowedArr;
