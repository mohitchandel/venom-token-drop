import { Transaction, TransactionsBatchInfo } from './models';
/**
 * @category Utils
 */
export type UniqueArray<T> = T extends readonly [infer X, ...infer Rest] ? InArray<Rest, X> extends true ? ['Encountered value with duplicates:', X] : readonly [X, ...UniqueArray<Rest>] : T;
/**
 * @category Utils
 */
export type InArray<T, X> = T extends readonly [X, ...infer _Rest] ? true : T extends readonly [X] ? true : T extends readonly [infer _, ...infer Rest] ? InArray<Rest, X> : false;
/**
 * @category Utils
 */
export type ArrayItemType<T extends readonly unknown[]> = T extends readonly (infer Ts)[] ? Ts : never;
/**
 * @category Utils
 */
export declare class Address {
    private readonly _address;
    constructor(address: string);
    toString(): string;
    toJSON(): string;
    equals: (other: Address | string) => boolean;
    private _equals;
}
/**
 * Check whether the provider object is instance of `Address`,
 * handling the case of duplicated dependencies.
 */
export declare function isAddressObject(address: object | null): boolean;
/**
 * @category Utils
 */
export declare class AddressLiteral<T extends string> extends Address {
    constructor(address: CheckAddress<T>);
}
/**
 * @category Utils
 */
export type CheckAddress<T extends string> = AddressImpl<T, Lowercase<T>>;
type AddressPrefix = '0:' | '-1:';
type AddressImpl<T, Tl extends string> = Tl extends `${AddressPrefix}${infer Hash}` ? true extends IsHexString<Hash, []> ? T : never : never;
type HexSymbol = '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f';
type HexByte = `${HexSymbol}${HexSymbol}`;
type IsHexString<T extends string, L extends readonly number[]> = T extends `${HexByte}${infer Tail}` ? IsHexString<Tail, [...L, 0]> : T extends '' ? L['length'] extends 32 ? true : never : never;
/**
 * @category Utils
 */
export declare class MessageExpiredException extends Error {
    readonly address: Address;
    readonly hash: string;
    constructor(address: Address, hash: string);
}
export declare class DelayedTransactions {
    private readonly transactions;
    waitTransaction(address: Address, hash: string): Promise<Transaction>;
    fillTransaction(hash: string, transaction?: Transaction): void;
}
/**
 * @category Utils
 */
export declare class Semaphore {
    private tasks;
    count: number;
    constructor(count: number);
    acquire(): Promise<() => void>;
    releaseAll(): void;
    sched: () => void;
}
/**
 * @category Utils
 */
export declare const LT_COLLATOR: Intl.Collator;
/**
 * Modifies knownTransactions array, merging it with new transactions.
 * All arrays are assumed to be sorted by descending logical time.
 *
 * > Note! This method does not remove duplicates.
 *
 * @param knownTransactions
 * @param newTransactions
 * @param info
 *
 * @category Utils
 */
export declare function mergeTransactions<Addr>(knownTransactions: Transaction<Addr>[], newTransactions: Transaction<Addr>[], info: TransactionsBatchInfo): Transaction<Addr>[];
export declare function getUniqueId(): number;
export {};
